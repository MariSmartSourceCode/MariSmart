{"version":3,"file":"prismeditor.cjs.production.min.js","sources":["../src/Editor.ts"],"sourcesContent":["import Vue, { VNode } from 'vue';\n\nimport './styles.css';\nconst KEYCODE_ENTER = 13;\nconst KEYCODE_TAB = 9;\nconst KEYCODE_BACKSPACE = 8;\nconst KEYCODE_Y = 89;\nconst KEYCODE_Z = 90;\nconst KEYCODE_M = 77;\nconst KEYCODE_PARENS = 57;\nconst KEYCODE_BRACKETS = 219;\nconst KEYCODE_QUOTE = 222;\nconst KEYCODE_BACK_QUOTE = 192;\nconst KEYCODE_ESCAPE = 27;\n\nconst HISTORY_LIMIT = 100;\nconst HISTORY_TIME_GAP = 3000;\n\nconst isWindows = typeof window !== 'undefined' && navigator && /Win/i.test(navigator.platform);\nconst isMacLike = typeof window !== 'undefined' && navigator && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n\nexport interface EditorProps {\n  lineNumbers: boolean;\n  autoStyleLineNumbers: boolean;\n  readonly: boolean;\n  value: string;\n  highlight: () => string;\n  tabSize: number;\n  insertSpaces: boolean;\n  ignoreTabKey: boolean;\n  placeholder: string;\n}\nexport interface Record {\n  value: string;\n  selectionStart: number;\n  selectionEnd: number;\n}\n\nexport interface History {\n  stack: Array<Record & { timestamp: number }>;\n  offset: number;\n}\n\nexport const PrismEditor = Vue.extend({\n  props: {\n    lineNumbers: {\n      type: Boolean,\n      default: false,\n    },\n    autoStyleLineNumbers: {\n      type: Boolean,\n      default: true,\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n    value: {\n      type: String,\n      default: '',\n    },\n    highlight: {\n      type: Function,\n      required: true,\n    },\n    tabSize: {\n      type: Number,\n      default: 2,\n    },\n    insertSpaces: {\n      type: Boolean,\n      default: true,\n    },\n    ignoreTabKey: {\n      type: Boolean,\n      default: false,\n    },\n    placeholder: {\n      type: String,\n      default: '',\n    },\n  },\n  data() {\n    return {\n      capture: true,\n      history: {\n        stack: [],\n        offset: -1,\n      } as History,\n      lineNumbersHeight: '20px',\n      codeData: '',\n    };\n  },\n  watch: {\n    value: {\n      immediate: true,\n      handler(newVal: string): void {\n        if (!newVal) {\n          this.codeData = '';\n        } else {\n          this.codeData = newVal;\n        }\n      },\n    },\n    content: {\n      immediate: true,\n      handler(): void {\n        if (this.lineNumbers) {\n          this.$nextTick(() => {\n            this.setLineNumbersHeight();\n          });\n        }\n      },\n    },\n    lineNumbers(): void {\n      this.$nextTick(() => {\n        this.styleLineNumbers();\n        this.setLineNumbersHeight();\n      });\n    },\n  },\n  computed: {\n    isEmpty(): boolean {\n      return this.codeData.length === 0;\n    },\n    content(): string {\n      const result = this.highlight(this.codeData) + '<br />';\n      // todo: VNode support?\n      return result;\n    },\n    lineNumbersCount(): number {\n      const totalLines = this.codeData.split(/\\r\\n|\\n/).length;\n      return totalLines;\n    },\n  },\n  mounted() {\n    this._recordCurrentState();\n    this.styleLineNumbers();\n  },\n\n  methods: {\n    setLineNumbersHeight(): void {\n      this.lineNumbersHeight = getComputedStyle(this.$refs.pre as HTMLTextAreaElement).height;\n    },\n    styleLineNumbers(): void {\n      if (!this.lineNumbers || !this.autoStyleLineNumbers) return;\n\n      const $editor = this.$refs.pre as HTMLTextAreaElement;\n      const $lineNumbers: HTMLDivElement | null = this.$el.querySelector('.prism-editor__line-numbers');\n      const editorStyles = window.getComputedStyle($editor);\n\n      this.$nextTick(() => {\n        const btlr: any = 'border-top-left-radius';\n        const bblr: any = 'border-bottom-left-radius';\n        if (!$lineNumbers) return;\n        $lineNumbers.style[btlr] = editorStyles[btlr];\n        $lineNumbers.style[bblr] = editorStyles[bblr];\n        $editor.style[btlr] = '0';\n        $editor.style[bblr] = '0';\n\n        const stylesList = ['background-color', 'margin-top', 'padding-top', 'font-family', 'font-size', 'line-height'];\n        stylesList.forEach((style: any) => {\n          $lineNumbers.style[style] = editorStyles[style];\n        });\n        $lineNumbers.style['margin-bottom' as any] = '-' + editorStyles['padding-top' as any];\n      });\n    },\n    _recordCurrentState(): void {\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n\n      if (!input) return;\n      // Save current state of the input\n      const { value, selectionStart, selectionEnd } = input;\n\n      this._recordChange({\n        value,\n        selectionStart,\n        selectionEnd,\n      });\n    },\n    _getLines(text: string, position: number): Array<string> {\n      return text.substring(0, position).split('\\n');\n    },\n    _applyEdits(record: Record): void {\n      // Save last selection state\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n      const last = this.history.stack[this.history.offset];\n\n      if (last && input) {\n        this.history.stack[this.history.offset] = {\n          ...last,\n          selectionStart: input.selectionStart,\n          selectionEnd: input.selectionEnd,\n        };\n      }\n\n      // Save the changes\n      this._recordChange(record);\n      this._updateInput(record);\n    },\n    _recordChange(record: Record, overwrite = false): void {\n      const { stack, offset } = this.history;\n\n      if (stack.length && offset > -1) {\n        // When something updates, drop the redo operations\n        this.history.stack = stack.slice(0, offset + 1);\n\n        // Limit the number of operations to 100\n        const count = this.history.stack.length;\n\n        if (count > HISTORY_LIMIT) {\n          const extras = count - HISTORY_LIMIT;\n\n          this.history.stack = stack.slice(extras, count);\n          this.history.offset = Math.max(this.history.offset - extras, 0);\n        }\n      }\n\n      const timestamp = Date.now();\n\n      if (overwrite) {\n        const last = this.history.stack[this.history.offset];\n\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n          // A previous entry exists and was in short interval\n\n          // Match the last word in the line\n          const re = /[^a-z0-9]([a-z0-9]+)$/i;\n\n          // Get the previous line\n          const previous = this._getLines(last.value, last.selectionStart).pop()?.match(re);\n\n          // Get the current line\n          const current = this._getLines(record.value, record.selectionStart).pop()?.match(re);\n\n          if (previous && current && current[1].startsWith(previous[1])) {\n            // The last word of the previous line and current line match\n            // Overwrite previous entry so that undo will remove whole word\n            this.history.stack[this.history.offset] = {\n              ...record,\n              timestamp,\n            };\n\n            return;\n          }\n        }\n      }\n\n      // Add the new operation to the stack\n      this.history.stack.push({ ...record, timestamp });\n      this.history.offset++;\n    },\n\n    _updateInput(record: Record): void {\n      const input = this.$refs.textarea as HTMLTextAreaElement;\n\n      if (!input) return;\n\n      // Update values and selection state\n      input.value = record.value;\n      input.selectionStart = record.selectionStart;\n      input.selectionEnd = record.selectionEnd;\n\n      this.$emit('input', record.value);\n      // this.props.onValueChange(record.value);\n    },\n    handleChange(e: KeyboardEvent): void {\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\n\n      this._recordChange(\n        {\n          value,\n          selectionStart,\n          selectionEnd,\n        },\n        true\n      );\n      this.$emit('input', value);\n      // this.props.onValueChange(value);\n    },\n    _undoEdit(): void {\n      const { stack, offset } = this.history;\n\n      // Get the previous edit\n      const record = stack[offset - 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n        this.history.offset = Math.max(offset - 1, 0);\n      }\n    },\n    _redoEdit(): void {\n      const { stack, offset } = this.history;\n\n      // Get the next edit\n      const record = stack[offset + 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        this._updateInput(record);\n        this.history.offset = Math.min(offset + 1, stack.length - 1);\n      }\n    },\n    handleKeyDown(e: KeyboardEvent): void {\n      // console.log(navigator.platform);\n      const { tabSize, insertSpaces, ignoreTabKey } = this;\n\n      if (this.$listeners.keydown) {\n        // onKeyDown(e);\n        this.$emit('keydown', e);\n\n        if (e.defaultPrevented) {\n          return;\n        }\n      }\n\n      if (e.keyCode === KEYCODE_ESCAPE) {\n        (<HTMLTextAreaElement>e.target).blur();\n        this.$emit('blur', e);\n      }\n\n      const { value, selectionStart, selectionEnd } = e.target as HTMLTextAreaElement;\n\n      const tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.capture) {\n        // Prevent focus change\n        e.preventDefault();\n\n        if (e.shiftKey) {\n          // Unindent selected lines\n          const linesBeforeCaret = this._getLines(value, selectionStart);\n          const startLine = linesBeforeCaret.length - 1;\n          const endLine = this._getLines(value, selectionEnd).length - 1;\n          const nextValue = value\n            .split('\\n')\n            .map((line, i) => {\n              if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\n                return line.substring(tabCharacter.length);\n              }\n\n              return line;\n            })\n            .join('\\n');\n\n          if (value !== nextValue) {\n            const startLineText = linesBeforeCaret[startLine];\n\n            this._applyEdits({\n              value: nextValue,\n              // Move the start cursor if first line in selection was modified\n              // It was modified only if it started with a tab\n              selectionStart: startLineText.startsWith(tabCharacter)\n                ? selectionStart - tabCharacter.length\n                : selectionStart,\n              // Move the end cursor by total number of characters removed\n              selectionEnd: selectionEnd - (value.length - nextValue.length),\n            });\n          }\n        } else if (selectionStart !== selectionEnd) {\n          // Indent selected lines\n          const linesBeforeCaret = this._getLines(value, selectionStart);\n          const startLine = linesBeforeCaret.length - 1;\n          const endLine = this._getLines(value, selectionEnd).length - 1;\n          const startLineText = linesBeforeCaret[startLine];\n\n          this._applyEdits({\n            value: value\n              .split('\\n')\n              .map((line, i) => {\n                if (i >= startLine && i <= endLine) {\n                  return tabCharacter + line;\n                }\n\n                return line;\n              })\n              .join('\\n'),\n            // Move the start cursor by number of characters added in first line of selection\n            // Don't move it if it there was no text before cursor\n            selectionStart: /\\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n            // Move the end cursor by total number of characters added\n            selectionEnd: selectionEnd + tabCharacter.length * (endLine - startLine + 1),\n          });\n        } else {\n          const updatedSelection = selectionStart + tabCharacter.length;\n\n          this._applyEdits({\n            // Insert tab character at caret\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\n        const hasSelection = selectionStart !== selectionEnd;\n        const textBeforeCaret = value.substring(0, selectionStart);\n\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n          // Prevent default delete behaviour\n          e.preventDefault();\n\n          const updatedSelection = selectionStart - tabCharacter.length;\n\n          this._applyEdits({\n            // Remove tab character at caret\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      } else if (e.keyCode === KEYCODE_ENTER) {\n        // Ignore selections\n        if (selectionStart === selectionEnd) {\n          // Get the current line\n          const line = this._getLines(value, selectionStart).pop();\n          const matches = line?.match(/^\\s+/);\n\n          if (matches && matches[0]) {\n            e.preventDefault();\n\n            // Preserve indentation on inserting a new line\n            const indent = '\\n' + matches[0];\n            const updatedSelection = selectionStart + indent.length;\n\n            this._applyEdits({\n              // Insert indentation character at caret\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n              // Update caret position\n              selectionStart: updatedSelection,\n              selectionEnd: updatedSelection,\n            });\n          }\n        }\n      } else if (\n        e.keyCode === KEYCODE_PARENS ||\n        e.keyCode === KEYCODE_BRACKETS ||\n        e.keyCode === KEYCODE_QUOTE ||\n        e.keyCode === KEYCODE_BACK_QUOTE\n      ) {\n        let chars;\n\n        if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n          chars = ['(', ')'];\n        } else if (e.keyCode === KEYCODE_BRACKETS) {\n          if (e.shiftKey) {\n            chars = ['{', '}'];\n          } else {\n            chars = ['[', ']'];\n          }\n        } else if (e.keyCode === KEYCODE_QUOTE) {\n          if (e.shiftKey) {\n            chars = ['\"', '\"'];\n          } else {\n            chars = [\"'\", \"'\"];\n          }\n        } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n          chars = ['`', '`'];\n        }\n\n        // console.log(isMacLike, \"navigator\" in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform));\n\n        // If text is selected, wrap them in the characters\n        if (selectionStart !== selectionEnd && chars) {\n          e.preventDefault();\n\n          this._applyEdits({\n            value:\n              value.substring(0, selectionStart) +\n              chars[0] +\n              value.substring(selectionStart, selectionEnd) +\n              chars[1] +\n              value.substring(selectionEnd),\n            // Update caret position\n            selectionStart,\n            selectionEnd: selectionEnd + 2,\n          });\n        }\n      } else if (\n        (isMacLike\n          ? // Trigger undo with ⌘+Z on Mac\n            e.metaKey && e.keyCode === KEYCODE_Z\n          : // Trigger undo with Ctrl+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z) &&\n        !e.shiftKey &&\n        !e.altKey\n      ) {\n        e.preventDefault();\n\n        this._undoEdit();\n      } else if (\n        (isMacLike\n          ? // Trigger redo with ⌘+Shift+Z on Mac\n            e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\n          : isWindows\n          ? // Trigger redo with Ctrl+Y on Windows\n            e.ctrlKey && e.keyCode === KEYCODE_Y\n          : // Trigger redo with Ctrl+Shift+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\n        !e.altKey\n      ) {\n        e.preventDefault();\n\n        this._redoEdit();\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n        e.preventDefault();\n\n        // Toggle capturing tab key so users can focus away\n        this.capture = !this.capture;\n      }\n    },\n  },\n  render(h): VNode {\n    const lineNumberWidthCalculator = h(\n      'div',\n      {\n        attrs: {\n          class: 'prism-editor__line-width-calc',\n          style: 'height: 0px; visibility: hidden; pointer-events: none;',\n        },\n      },\n      '999'\n    );\n    const lineNumbers = h(\n      'div',\n      {\n        staticClass: 'prism-editor__line-numbers',\n        style: {\n          'min-height': this.lineNumbersHeight,\n        },\n        attrs: {\n          'aria-hidden': 'true',\n        },\n      },\n      [\n        lineNumberWidthCalculator,\n        Array.from(Array(this.lineNumbersCount).keys()).map((_, index) => {\n          return h('div', { attrs: { class: 'prism-editor__line-number token comment' } }, `${++index}`);\n        }),\n      ]\n    );\n\n    const textarea = h('textarea', {\n      ref: 'textarea',\n      on: {\n        input: this.handleChange,\n        keydown: this.handleKeyDown,\n        click: ($event: MouseEvent) => {\n          this.$emit('click', $event);\n        },\n        keyup: ($event: KeyboardEvent) => {\n          this.$emit('keyup', $event);\n        },\n        focus: ($event: FocusEvent) => {\n          this.$emit('focus', $event);\n        },\n        blur: ($event: FocusEvent) => {\n          this.$emit('blur', $event);\n        },\n      },\n      staticClass: 'prism-editor__textarea',\n      class: {\n        'prism-editor__textarea--empty': this.isEmpty,\n      },\n      attrs: {\n        spellCheck: 'false',\n        autocapitalize: 'off',\n        autocomplete: 'off',\n        autocorrect: 'off',\n        'data-gramm': 'false',\n        placeholder: this.placeholder,\n        'data-testid': 'textarea',\n        readonly: this.readonly,\n      },\n      domProps: {\n        value: this.codeData,\n      },\n    });\n    const preview = h('pre', {\n      ref: 'pre',\n      staticClass: 'prism-editor__editor',\n      attrs: {\n        'data-testid': 'preview',\n      },\n      domProps: {\n        innerHTML: this.content,\n      },\n    });\n    const editorContainer = h('div', { staticClass: 'prism-editor__container' }, [textarea, preview]);\n    return h('div', { staticClass: 'prism-editor-wrapper' }, [this.lineNumbers && lineNumbers, editorContainer]);\n  },\n});\n"],"names":["isWindows","window","navigator","test","platform","isMacLike","PrismEditor","Vue","extend","props","lineNumbers","type","Boolean","autoStyleLineNumbers","readonly","value","String","highlight","Function","required","tabSize","Number","insertSpaces","ignoreTabKey","placeholder","data","capture","history","stack","offset","lineNumbersHeight","codeData","watch","immediate","handler","newVal","content","this","$nextTick","_this","setLineNumbersHeight","_this2","styleLineNumbers","computed","isEmpty","length","lineNumbersCount","split","mounted","_recordCurrentState","methods","getComputedStyle","$refs","pre","height","$editor","$lineNumbers","$el","querySelector","editorStyles","btlr","bblr","style","forEach","input","textarea","_recordChange","selectionStart","selectionEnd","_getLines","text","position","substring","_applyEdits","record","last","_updateInput","overwrite","slice","count","extras","Math","max","timestamp","Date","now","re","previous","pop","_this$_getLines$pop","match","current","_this$_getLines$pop2","startsWith","push","$emit","handleChange","e","target","_undoEdit","_redoEdit","min","handleKeyDown","$listeners","keydown","defaultPrevented","keyCode","blur","tabCharacter","repeat","preventDefault","shiftKey","linesBeforeCaret","startLine","endLine","nextValue","map","line","i","join","startLineText","updatedSelection","hasSelection","endsWith","matches","indent","chars","metaKey","ctrlKey","altKey","render","h","lineNumberWidthCalculator","attrs","staticClass","Array","from","keys","_","index","ref","on","click","$event","_this3","keyup","focus","spellCheck","autocapitalize","autocomplete","autocorrect","domProps","preview","innerHTML","editorContainer"],"mappings":"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"}